# Coze's `x` is derived from `d` assumption
Coze assumes that `x` is derived from `d`.  In all Coze supported signing
algorithms (ES224, ES256, ES384, ES512, Ed25519, Ed25519ph) x is directly
related to d and so assumption is valid.  We plan on keeping this assumption in
place when supporting future algorithms.  A consequence of this assumption is
that d is equivalent to a seed.  

Under some hypothetical signing schemes, what an algorithm calls the public
key,`x`, may not be derivable from what the algorithm names the private key,
`d`. The algorithm would argue that `d` and `x` may be generated at the same
time and the relationship isn't knowable without both fields.  Even under that
circumstance, there must be a common source that `x` and `d` were derived from.
Instead of using algorithm recommended values for "the private key", Coze can
define a "seed as d" so the assumption `x` is related to `d` can remain in
place.  Non-seed private components can be appended to the end of `d`. 

Breaking the `x` is derivable from `d` assumption would require a change to Go
Coze functions `calcX` and `Correct()` and would likely require concatenation of
private components into `d`.  Adding new key fields for private components is
not desireable and makes the logic handling private component more difficult. If
caching of private components is needed, those components should be appended to
`d` and an concatenation method defined by Coze.  

This situation was encountered with Ed25519.  The early written specification
suggested using "secrete scalar s" (sss) as the private key, and x wasn't
derivable from sss.  Implementations found using "seed" as the private key was
more ideal.  When using seed for the value of "the private key", x is derivable.
SSS may be cached, and seed is stored as the "private key".   See also,
Ed25519's naming differences in implementations, (see
https://github.com/Cyphrme/ed25519_applet#naming-differences-in-implementations).
In Coze, "d" is the RFC's seed and sss is recomputed when needed.

How does this assumption affect checksums? If x was not derivable from d, tmb
cannot serve as the checksum for d.  Otherwise, x may be used as a checksum for
d.  


# Proposal: Checksums and Truncatable Thumbprints

Before considering checksums, consider using `sig` as an integrity check via
cryptographic verification.  This precludes most utility of secondary checksums.  

## Checksums

In Coze, all checksums are generated by hashing the value that the checksum is
on. Checksum's hashing algorithm must align with `alg`.  Checksums may be
truncated to any size.   

Checksums begin after the character tilde, `~`.  Checksums must not begin
strings.  

Example:
```JSON
{
  "tmb":"cLj8vsYtMBwYkzoFVZHBZo6SNL8wSdCIjCKAwXNuhOk~WR_2EpmB3e6ldoPl5VFTC_09BxeumOv3XvIB55igkZg"
}
```

Which may be truncated:

```JSON
{
  "tmb":"cLj8vsYtMBwYkzoFVZHBZo6SNL8wSdCIjCKAwXNuhOk~WR_2"
}
```

## Truncatable Thumbprints
Thumbprint is truncated at `~`

```json
{
  "tmb":"cLj8vs~"
}
```

Serialized form:
```
alg:d::cLj8vs~
```

### ~ as checksum delimiter
If going with the delimited option, ~ seems reasonable. 

- Not base64ut
- URL safe character.  
- Last ASCII character.  


## Cryptographic considerations

`x` and `d` may leak cryptographic information, and so user may not want to
disclose them under certain circumstances.  Since `tmb` is a digest, it may
always be used as a checksum.  


## Checksum Coze three letter field name
Currently, this isn't needed, but if it ever were, this would be the three
letter field name.

Checksum field name: `chk`





# Checksum utility

For the key below, checksums are not useful because:
1. tmb is the checksum of x.
2. x may be recalculated from d, so x serves as the checksum of d.  

```JSON
{
	"alg":"ES256",
	"iat":1623132000,
	"kid":"Zami's Majuscule Key.",
	"d":"bNstg4_H3m3SlROufwRSEgibLrBuRq9114OvdapcpVA",
	"tmb":"cLj8vsYtMBwYkzoFVZHBZo6SNL8wSdCIjCKAwXNuhOk",
	"x":"2nTOaFVm2QLxmUO_SjgyscVHBtvHEfo2rq65MvgNRjORojq39Haq9rXNxvXxwba_Xj0F5vZibJR3isBdOWbo5g"
}
```

Checksums would be useful here:

```
{
	"alg":"ES256",
	"iat":1623132000,
	"kid":"Zami's Majuscule Key.",
	"tmb":"cLj8vsYtMBwYkzoFVZHBZo6SNL8wSdCIjCKAwXNuhOk",
}
```

Proposed form:
```
{
	"alg":"ES256",
	"iat":1623132000,
	"kid":"Zami's Majuscule Key.",
	"tmb":"cLj8vsYtMBwYkzoFVZHBZo6SNL8wSdCIjCKAwXNuhOk~WR_2EpmB3e6ldoPl5VFTC_09BxeumOv3XvIB55igkZg",
}
```

Serialized form and truncated to 4 characters:

``` 
ES256:cLj8vsYtMBwYkzoFVZHBZo6SNL8wSdCIjCKAwXNuhOk~WR_2
```


## Serialized Form 
If sending the short serialized form, `d`, `x`, `tmb` would benefit from
checksums.

### Useful
These are the only forms that `chk` is useful.  All other forms are redundant.  

```
alg:d~chk::
alg:x~chk:
alg:tmb~chk
```

### Redundant (don't do this)
Any combination of two or more Coze fields [`d`,`x`,`tmb`], including the following:

- `alg:x:tmb~chk`
    - tmb already serves as the checksum of x.  
- `alg:d~chk:x:`
   - x is derived from d and so x may serve as a checksum.    
- `alg:d~chk::tmb`
    - tmb is derived from x, which x is derived from d and so tmb may serve as a checksum for d.
- `alg:d~chk::tmb~chk`
- `alg:d~chk:x~chk:`
- `alg:d~chk:x~chk:tmb~chk` 

The only reason to do these forms is if your system does not have the ability to
do signatures, but does have the ability to check digests.  This would be a
mostly unreasonable circumstance.  


# Requiring Correct() calls to use any given component (`d`, `x`, `tmb`) as a checksum
Applications should just do this by default, imho.  

Alternatively:

 1. Should applications be required to checksum if checksumming is possible?

 2. Alternatively, checksumming could be forced only when checksum is present,
    but all components should be checked. 

 3. Alternatively, only items with checksums are checksummed.  

Option 1 is the most robust.  2 is somewhat expected.  3 is easy to code.  



# Serialized Form for Coze Keys
Colon `:` is used as the serialized component delimiter.  Although "url unsafe",
as it is widely used in URLs without issue.

## Serialized Forms 

`chk` is checksum.  

	alg:izd:d:x:tmb
	alg:d:x:tmb
	alg:d:x:
	alg:x:tmb
	alg:tmb
	alg:tmb~chk
	alg:d::tmb
	alg:izd:::


### Why Specify Alg?  (Weakest link problem and "bad" crypto agility.  )



An alternative is to:
 - Assume that all digests of a similar size have a similar strength. All
   digests in a given class are considered secure.  If a class gets a "weak"
   member, applications can require explicit alg denotation (This is
   hard/tricky/messy, so this is not something we'd advocate for. )



# Self-describing text encoding
In the future, it would be nice to support other encoding and/or support
self-describing.

One of the less than universal design choices is that Coze opinionatedly uses
JSON, a text encoding, for cryptographic functions. Using text encoding may or
may not be ergonomic for other systems. Coze does this carefully, and we think
efficiently, but it's still a concern.  

(Not that SSH also does this.  SSH's fingerprint is the hash of the _ub64t_ (not
b64ut) encoding of the public key.)

Self-described encoding allows binary value to be used in future designs to
lessen the coupling with the text encoding design choice. 

For other future designs to be supported, Coze needs escape.  Since b64ut uses a
small subset of characters, escaping now doesn't seem to be a big issue.  Any
non-base64 character may be used to self-describe encoding as a value. 

To stay JSON compliant, quotes are needed around values.  Extending JSON and
using self-describing syntax would allow the dropping of the quotes.

Cyphr.me has an internal system of self-describing that might be used as well.
See the README in Cyphr.me's basecnv package section "Self-describing".



## Base and Encoding Notation
The following characters are good delimiter candidates:

```
~!.:=
```

The second character is the last character in the alphabet, thus denoting
both base and alphabet.  

For example, to represent Cyphr.me Base 64 (Not b64ut):

```
~_
```

Thus "Zami's Majuscule Key" (if using pure Base 64 and not b64ut) would be
represented by:


```
~_cLj8vsYtMBwYkzoFVZHBZo6SNL8wSdCIjCKAwXNuhOk
```


This scheme will already be compatible with Coze since b64ut is not compatible
with the character `~`.  


Further notation would be needed to denote bucket conversion, padding, and other
options.  (The work of generalizing bucket conversion is not yet completed.)

## Special
Perhaps there's a need for a "special" delimiter that denotes "legacy" bases.  
For b64ut

```
!u
```

Where "!" denotes a legacy/standard and the second character is the character
for the [multibase](https://github.com/multiformats/multibase#multibase-table)
encoding. 


Thus "Zami's Majuscule Key"  would be represented by:


```
!ucLj8vsYtMBwYkzoFVZHBZo6SNL8wSdCIjCKAwXNuhOk
```





## See also:
https://github.com/multiformats/multiformats
https://multiformats.io/multihash/
